HW models:
* New prefix for hw models functions: nhw_ (nordic HW)

* Interrupt raising: nhw_<periph_type>_int_{raise/lower}(uint periph_inst)
  that maps to a to nhw_int_ctrl_int_raise(uint int_ctrl_inst, uint irq_nbr)
  Basic mapping just ifdef'ed
  Complex mapping table of int_map[inst] -> {int_ctrl_nbr, int_nbr}

* nhw_dppi_event_signal(uint dppi_inst, uint channel_nbr)
* nhw_dppi_channel_subscribe(uint dppi_inst, uint channel_nbr, callback)
	Add to the channel list the callback which will be called

* Number of instances
  Common header def: NRF_HW_config.h
    NHW_<PERIPH_TYPE>_NCORES
    NHW_<PERIPH_TYPE>_NINST = { , , }
    NHW_<PERIPH_TYPE>_TOTAL_INST = __sum__(NHW_<PERIPH_TYPE>_NINST)
    NHW_<PERIPH_TYPE>_<CORE>_<INST> = __index_in_total_of_ninst
  Peripheral:
    ~static uint <Periph_type>_NIST[NHW_<PERIPH_TYPE>_NCORES] = NHW_<PERIPH_TYPE>_NINST;~
    struct nhw_<periph_type>_st_type {
      bs_time_t <PERIPH_TYPE>_timer
      ..other status.
      NRF_<PERIPH_TYPE>_Type NRF_<PERIPH_TYPE>_regs;
      };
    NRF_<PERIPH_TYPE>_Type *NRF_<PERIPH_TYPE>_regs[NHW_<PERIPH_TYPE>_TOTAL_INST];

    static struct nhw_<periph_type>_st_type { } *nhw_<periph_type>_st[];

    Init: 
      for each instance
      	nhw_<periph_type>_st[i] = calloc(sizeof(struct nhw_<periph_type>_st_type))
      	NRF_<PERIPH_TYPE>_regs = &nhw_<periph_type>_st[i].NRF_<PERIPH_TYPE>_regs;

  mdk_replacements/nrf_bsim_redef.h
    #if <SOC>
    	extern NRF_<PERIPH_TYPE>_Type *NRF_<PERIPH_TYPE>_regs[];
      #define NRF_<PERIPH_TYPE><INST>_BASE  (NRF_<PERIPH_TYPE>_regs[<whichever_corresponds>])
    #else.. 


Types:
* Interrupts: (internal to HW models)
  enum CPU<N>_IRQ_Type { CPU<N>_PERIPH_IRQn }
  Copied from the respective MDK header (nrf5340_network.h)
  RADIO_IRQn -> CPUNET_RADIO_IRQn

* Peripherals SW/HW registers IF (internal to HW models)
  Wherever possible, common types
  - For ones with differents between instances, (and proper reserverd spacing), make common of both.
    And provide also 
    NHW_CLOCK_NET_Type & NHW_CLOCK_APP_Type types
  - UICR and FICR: Common part just own big enough reserved blob, and map on top
    NHW_FICR_NET_Type & NHW_FICR_APP_Type


Things to note in documentation:
* All peripherals memory mapped registers are actually accessible from all CPU cores
* The secure and non-secure memory map aliases to a peripheral target the same place
* There is no secure or non-secure differentiation in the accesses.

